using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Text;
using System.Collections.Generic;
using System.Console;
using System.Linq;
using Nemerle.Json;
using System.IO;
using System.Diagnostics;

namespace IssuesGet
{

  module Program
  {

    public GetTime(this obj : JObject) : DateTime
    {
      if (obj.IsNull()) DateTime.MinValue else 
      {
        def str = obj.GetString();
        DateTime.Parse(str)
      }
    }

    public GetString(this obj : JObject) : string
    {
      if (obj.IsNull()) null else obj.ToString().Trim('"')
    }

    public GetInt(this obj : JObject) : int
    {
      | JObject.Value(JValue.Number(val)) => val :> int
      | _                                 => throw InvalidDataException("value is not integer in json JObject")
    }

    public GetString(this obj : JValue) : string
    {
      | JValue.Null => null
      | _           => obj.ToString().Trim('"')
    }

    public IsNull(this obj : JObject) : bool
    {
      | JObject.Value(JValue.Null) => true
      | _                          => false
    }

    public GetArray[T](this obj : JObject, func : JObject -> T) : list[T]
    {
      match (obj)
      {
        | JObject.Array(lst) => lst.Map(func)
        | _                  => throw InvalidDataException("value is not array in json JObject")
      }
    }

    IssueFromObject(obj : Dictionary[string, JObject]) : Issue
    {
      def title   = obj["title"].GetString();
      def updated = obj["updated_at"].GetTime();
      def opened  = obj["state"].GetString() == "open";
      def user    = obj["user"].Get("login").GetString();
      def num     = obj["number"].GetInt();
      def assign  = obj["assignee"].Get("login").GetString();
      def mile    = obj["milestone"];
      def mile    = if (mile.IsNull()) null else IssueMilestone(mile.Get("title").GetString(), mile.Get("state").GetString() == "open");
      def created = obj["created_at"].GetTime();
      def closed  = obj["closed_at"].GetTime();
      def labels  = obj["labels"].GetArray(x => x.Get("name").GetString());
      Issue(updated, title, opened, user, num, assign, mile, created, closed, labels)
    }

    ProcessIssueObject(obj : JObject) : Issue
    {
      | Object(lst) => IssueFromObject(lst.ToDictionary((x, _) => x, (_, y) => y))
      | _           => null
    }

    public Get(this obj : JObject, name : string) : JValue
    {
      match (obj)
      {
        | JObject.Object(items)           => 
                                              match (items.Find((x, _) => x == name))
                                              {
                                                | Some((_, JObject.Value(v))) => v
                                                | _                           => throw InvalidDataException("key not found in json Object")
                                              }
        | JObject.Value(JValue.Null as j) => j
        | _                               => throw InvalidDataException("key not found in json Object")
      }
    }

    CreateString(page : int, closed : bool) : string
    {
      def closed = if (closed) "closed" else "open";
      $"https://api.github.com/repos/rsdn/Nemerle/issues?page=$(page)&state=$closed"
    }

    GetIssues(closed : bool = true) : IEnumerable[JObject]
    {
      def parser = JsonParser();
      def data = StringBuilder();
      def func = (_, x) => _ = data.Append(x.Data);
      
      def init(process)
      {
        process.StartInfo.FileName = "curl";
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.RedirectStandardOutput = true;
        process.OutputDataReceived += func;
      }

      def loop(page, issues)
      {
        def process = Process();
        init(process);
        process.StartInfo.Arguments = CreateString(page, closed);
        _ = process.Start();
        process.BeginOutputReadLine();
        process.WaitForExit();
        match (parser.Parse(data.ToString()))
        {
          | Some(JObject.Array([]))  => issues
          | Some(JObject.Array(lst)) => _ = data.Clear();
                                        loop(page + 1, issues.Concat(lst))
          | _                        => issues
        }
      }

      loop(1, Enumerable.Empty())
    }

    Main(_ : array[string]) : void
    {
      def getted = GetIssues(true);
      def issues = getted.Select(ProcessIssueObject);
      def issues = issues.OrderBy(_.Number);
      foreach (i in issues)
      {
        WriteLine($<#num:$(i.Number) title:$(i.Title) state:$(if (i.Opened) "open" else "closed") labels:..$(i.Labels)#>)
      }
    }
  }

}
