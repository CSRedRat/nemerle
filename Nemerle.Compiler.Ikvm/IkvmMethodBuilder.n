using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;
using Nemerle.Collections;
using Nemerle.Utility;

using IKVM.Reflection;
using System.IO;
using System.Diagnostics.SymbolStore;
using System.Diagnostics;
using System.Security;

using NC = Nemerle.Compiler;
using SR = IKVM.Reflection;
using SRE = IKVM.Reflection.Emit;
using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler.Sre
{
  internal sealed class IkvmMethodBuilder : MethodBuilder, IIkvmMethod, IIkvmMemberBuilder
  {
    public this(owner : TypeBuilder, ast : PT.ClassMember.Function, isProperty : bool)
    {
      base(owner, ast, isProperty)
    }

    /// system reflection emit method/constructor builder is stored here
    mutable method_base : SR.MethodBase;

    public GetHandle () : SR.MemberInfo
    {
      GetMethodBase ()
    }

    public GetMethodBase () : SR.MethodBase
    {
      assert (method_base != null);
      method_base
    }

    public GetConstructorInfo () : SRE.ConstructorBuilder
    {
      assert (method_base != null/* && method_base.IsConstructor*/);
      method_base :> SRE.ConstructorBuilder
    }

    public GetMethodInfo () : SRE.MethodBuilder
    {
      assert (method_base != null && !method_base.IsConstructor, declaring_type.FullName + "." + Name);
      method_base :> SRE.MethodBuilder
    }

    public CreateEmitBuilder (tb : Emit.TypeBuilder) : void
    {
      if (MemberKind == MemberKinds.Constructor)
        CreateConstructorBuilder (tb)
      else
        CreateMethodBuilder (tb)
    }

    public Compile () : void
    {
      RunBodyTyper ();

      when(HasConditionalAttribute)
        Manager.AttributeCompiler.Sre().CheckConditional(this);

      unless (modifiers.IsEmpty)
      {
        def adder =
          if (MemberKind == MemberKinds.Constructor)
            fun (target, attribute, shouldEmit, isSecurity)
            {
              if (target %&& System.AttributeTargets.Method)
              {
                when(shouldEmit)
                {
                  def builder = GetConstructorInfo();
                  if(isSecurity)
                    builder.__AddDeclarativeSecurity(attribute);
                  else
                    builder.SetCustomAttribute(attribute);
                }
                null
              }
              else if (attribute != null)
                "constructor " + ToString ()
              else
                null
            }
          else
            fun (target, attribute, shouldEmit, isSecurity)
            {
              if (target %&& System.AttributeTargets.Method)
              {
                when(shouldEmit)
                {
                  def builder = GetMethodInfo();
                  if(isSecurity)
                    builder.__AddDeclarativeSecurity(attribute);
                  else
                    builder.SetCustomAttribute(attribute);
                }
                null
              }
              else if (attribute != null)
                "method " + ToString ()
              else
                null
            };
        Manager.AttributeCompiler.Sre().SaveCustomAttributes(modifiers, declaring_type, adder);
      }

      unless(ReturnValueModifiers.IsEmpty)
      {
        Manager.AttributeCompiler.Sre().SaveCustomAttributes(ReturnValueModifiers, declaring_type,
          fun (target, attribute, shouldEmit, _isSecurity)
          {
            if (target %&& System.AttributeTargets.ReturnValue)
            {
              when(shouldEmit)
              {
                def ret = GetMethodInfo ().DefineParameter (0, ParameterAttributes.None, null);
                ret.SetCustomAttribute (attribute);
              }
              null
            }
            else if (attribute != null)
              "method " + ToString ()
            else
              null
          });
      }

      CompileAfterTyping ()
    }

    /**
     * Emits a method's body
     */
    internal CompileAfterTyping () : void
    {
      def setup_method (emitter : IkvmTypesManager)
      {
        // make sure type is not finalized
        def type_builder = declaring_type.SreBuilder().GetTypeBuilder();
        assert (type_builder != null);

        def mb = GetMethodInfo ();
        Util.cassert (mb != null, $"method builder is null for $this");

        /* update the entry point settings, if necessary */
        when (emitter._need_entry_point && Name == "Main"
          && (Manager.Options.MainClass == null
           || declaring_type.FullName == Manager.Options.MainClass
           || Manager.Options.IsMainClassAutogenerated))
        {
          def has_correct_signature ()
          {
            mb.IsStatic &&
            (ReturnType.Equals (InternalType.Int32) ||
             ReturnType.Equals (InternalType.Void)) &&
            match (fun_header.parms) {
              // workaround bug in MS PEVerify
              | [fp] =>
                fp.Type.Fix ().Equals (FixedType.Array (InternalType.String, 1))
              | [] => true
              | _ => false
            }
          }

          if (has_correct_signature ()) {
            if (declaring_type.TyparmsCount > 0 || !Header.typarms.IsEmpty)
              Message.Warning (402, this.ToString () + ": an entry point cannot be generic or in a generic type");
            else
              match (emitter._entry_point) {
                | Some (exist) =>
                  Message.Error ($ "more than one entry point (Main function) "
                                 "found, e.g. types $(exist.DeclaringType) and $(mb.DeclaringType)");
                  Message.Hint ("you can use -main TypeName switch to disambiguate selection");
                | None =>
                  //TODO: Implement IKVM SetUserEntryPoint
                  //when (emitter._debug_emit != null)
                  //  emitter._debug_emit.SetUserEntryPoint (SymbolToken (1));
                  emitter._entry_point = Some (mb : MethodInfo)
              }
          }
          else
            Message.Warning (28, $"$this has the wrong signature to be an entry point");
        }

        // update the overriding relationships
        foreach ((overriddenType, overridden) in ImplementedMethods)
        {
          // Message.Debug("override " + method_info.Name + " " + overridden_info.Name + " in " + type_builder.FullName);
          when (!mb.IsPublic || Name != overridden.Name)
          {
            // VladD2: Возможно вместо declaring_type.GetMemType() надо использовать
            def overridden_info = ILEmitter.GetMethodInfo(overriddenType, overridden);
            type_builder.DefineMethodOverride(mb, overridden_info)
          }
        }
      }

  //    Message.Debug (this.ToString ());
      match (fun_header.body)
      {
        | FunBody.ILed => {}
        | _ =>
          // maybe create additional method for implementing interface method
          // (in case of co/contravariant methods)
          CreateImplementsWrapper();

          // Message.Debug (Location, $ "compile: $this");

          Util.locate(Location,
          {
            match (fun_header.body)
            {
              | FunBody.ILed | FunBody.Parsed => Util.ice (fun_header.body.GetType().ToString ())

              | FunBody.Typed when Message.SeenError =>
                // just skip it
                fun_header.body = FunBody.ILed ()

              | FunBody.Typed =>
                assign_parameter_indexes(GetMethodBase().IsStatic);
                emit_parameter_attributes();
                unless (declaring_type.IsDelegate)
                {
                  unless (MemberKind == MemberKinds.Constructor)
                    setup_method(declaring_type.TyManager.Sre());

                  declaring_type.DoBeforeFinalization2 (
                    fun()
                    {
                      // Message.Debug ($"making il generator for $meth");
                      Manager.Backend.CodeEmitter.EmitMethodBody(this);
                    });
                }

              | FunBody.Abstract => emit_parameter_attributes();
            }
          });

          when (Manager.Options.EarlyExit)
            Message.MaybeBailout ();
      }
    }

    static parameter_attributes (fp : TParameter) : ParameterAttributes
    {
      (match (fp.Kind)
       {
        | ParmKind.Out => ParameterAttributes.Out
        | ParmKind.Ref
        | ParmKind.Normal => ParameterAttributes.None
       }
      )
      |
      (if (fp.default_value.IsSome)
         ParameterAttributes.HasDefault | ParameterAttributes.Optional
       else
         ParameterAttributes.None)
    }


    emit_parameter_attributes() : void
    {
      foreach (parm in fun_header.parms)
      {
        Manager.AttributeCompiler.Sre().SaveCustomAttributes(parm.Modifiers, declaring_type,
          fun(target, attr, shouldEmit, _isSecurity)
          {
            if (target %&& System.AttributeTargets.Parameter)
            {
              when(shouldEmit)
                parm.Sre().builder.SetCustomAttribute (attr);
              null
            }
            else
              "parameter " + parm.Name
          })
      }
    }


    /**
     * Assigns an ordinal index to each of a method's parameter
     */
    assign_parameter_indexes (is_static : bool) : void
    {
      mutable index = if (is_static) 0 else 1;

      foreach (parm in fun_header.parms)
      {
        parm.Decl.Sre().SetParmIndex(index, is_by_ref = parm.Kind != ParmKind.Normal);
        index++;
      }
    }


    /* build the parameter types array */
    param_types () : array [IKVM.Reflection.Type]
    {
      GetParameters ().MapToArray (fun (parm) { parm.Sre().GetSystemType() });
    }


    /**
     * Converts Nemerle modifiers to the CLI method attributes.
     */
    static make_method_attributes (attrs : NemerleAttributes) : MethodAttributes
    {
      mutable result = MethodAttributes.HideBySig;

      when (attrs %&& NemerleAttributes.Public)
        result |= MethodAttributes.Public;

      when (attrs %&& NemerleAttributes.Private)
        result |= MethodAttributes.Private;

      if (attrs %&& NemerleAttributes.Protected)
        if (attrs %&& NemerleAttributes.Internal)
          result |= MethodAttributes.FamORAssem;
        else
          result |= MethodAttributes.Family;
      else when (attrs %&& NemerleAttributes.Internal)
        result |= MethodAttributes.Assembly;

      when (attrs %&& NemerleAttributes.Static)
        result |= MethodAttributes.Static;

      when (attrs %&& NemerleAttributes.Override)
        result |= MethodAttributes.Virtual %| MethodAttributes.ReuseSlot;

      // when method is static, then new is only for compile-time information
      when (!(attrs %&& NemerleAttributes.Static) && attrs %&& NemerleAttributes.New && attrs %&& NemerleAttributes.Virtual)
        result |= MethodAttributes.NewSlot | MethodAttributes.Virtual;

      when (attrs %&& NemerleAttributes.Abstract)
        result |= MethodAttributes.Virtual %| MethodAttributes.Abstract;

      when (attrs %&& NemerleAttributes.Virtual)
        result |= MethodAttributes.Virtual;

      when (attrs %&& NemerleAttributes.Sealed)
        result |= MethodAttributes.Final %| MethodAttributes.Virtual;

      when (attrs %&& NemerleAttributes.SpecialName)
        result |= MethodAttributes.SpecialName;

      result
    }

    /**
     * Adds a method builder to a type builder
     */
    CreateMethodBuilder (tb : Emit.TypeBuilder) : void
    {
      // Message.Debug ($"-- AddMethodBuilder: $meth $(Attributes) ");

      /* update the modifiers list */
      unless (ImplementedMethods.IsEmpty)
        Attributes |= NemerleAttributes.Virtual;

      def attrs = make_method_attributes (Attributes);
      def attrs =
        if (Name == ".cctor")
          attrs | MethodAttributes.RTSpecialName | MethodAttributes.SpecialName
        else
          attrs;

      /* add the method to the type builder */
      mutable pinvoke = false;

      try
      {
        pinvoke = Manager.AttributeCompiler.Sre().CheckPInvoking(this);
        method_base = tb.DefineMethod(Name, if(pinvoke) attrs | MethodAttributes.PinvokeImpl else attrs);
        unless(fun_header.typarms.IsEmpty)
        {
          def names = fun_header.typarms.MapToArray (_.Name);
          def generic_parms = GetMethodInfo().DefineGenericParameters(names);
          foreach (gp in fun_header.typarms with index)
            gp.Sre().SetGenericBuilder(generic_parms[index]);
          foreach (gp in fun_header.typarms)
            gp.Sre().UpdateConstraints();
        }
      }
      catch
      {
        | e => throw System.ApplicationException (
          $"Can't define method '$Name' (attrs: $attrs) in type '$tb'.\nError: $(e.Message)", e);
      }

      GetMethodInfo ().SetSignature (
        fun_header.ret_type.GetSystemType(),
        fun_header.GetRetTypeRequiredModifiers.[IKVM.Reflection.Type](),
        fun_header.GetRetTypeOptionalModifiers.[IKVM.Reflection.Type](),
        param_types(),
        fun_header.GetParamTypeRequiredModifiers.[IKVM.Reflection.Type](),
        fun_header.GetParamTypeOptionalModifiers.[IKVM.Reflection.Type]());

      /* add the runtime modifiers for delegate methods */
      when (DeclaringType.IsDelegate) {
        assert (!pinvoke);
        GetMethodInfo ().SetImplementationFlags (
          MethodImplAttributes.Runtime | MethodImplAttributes.Managed
        )
      }

      when (!pinvoke && (Attributes & NemerleAttributes.Extern != 0))
        Message.Error (Location, "method is marked `extern' but do not have DllImport attribute");

      // CompileTypedMethod.compile_parms (hd);

      def name_parms (pos, parms)
      {
        match (parms) {
          | [] => ()
          | (p : TParameter) :: ps =>
            p.Sre().builder = GetMethodInfo ().DefineParameter (pos, parameter_attributes (p), p.Name);

            match (p.default_value) {
              | Some (TExpr.Literal (lit)) => p.Sre().builder.SetConstant(lit.AsObject());
              | Some (e) => Util.ice ($"complex expr $e");
              | None => {}
            }
            name_parms (pos + 1, ps)
        }
      }
      name_parms (1, GetParameters ());
    }

    /**
     * Adds a constructor builder to a type builder
     */
    CreateConstructorBuilder (tb : Emit.TypeBuilder) : void
    {
      // Message.Debug ($"-- AddConstructorBuilder: $this");

      /* create the constructor builder */
      method_base =
        tb.DefineConstructor (
          make_method_attributes (Attributes) |
          MethodAttributes.RTSpecialName |
          MethodAttributes.SpecialName,
          CallingConventions.Standard,
          param_types (),
          fun_header.GetParamTypeRequiredModifiers.[IKVM.Reflection.Type](),
          fun_header.GetParamTypeOptionalModifiers.[IKVM.Reflection.Type]());

      /* add the runtime modifiers for delegate constructors */
      when (DeclaringType.IsDelegate) {
        GetConstructorInfo ().SetImplementationFlags (
          MethodImplAttributes.Runtime | MethodImplAttributes.Managed
        )
      }

      def name_parms (pos, parms)
      {
        match (parms) {
          | [] => ()
          | (p : TParameter) :: ps =>
            p.Sre().builder = GetConstructorInfo ().DefineParameter (pos, parameter_attributes (p), p.Name);

            match (p.default_value) {
              | Some (TExpr.Literal (lit)) => p.Sre().builder.SetConstant(lit.AsObject());
              | Some (e) => Util.ice ($"complex expr $e");
              | None => ()
            }
            name_parms (pos + 1, ps)
        }
      }
      name_parms (1, GetParameters ());
    }

    CreateImplementsWrapper() : void
    {
      //Message.Debug($"check for impl wrap $this");
      // now we will create special wrappers implementing interface methods
      // when our methods are co/contra-variant (and .NET doesn't allow it automatically)
      def is_correct_impl(ifaceType : FixedType.Class, impl_meth : IMethod)
      {
        //Message.Debug($"compare: $(declaring_type.GetMemType().TypeOfMember(impl_meth))     ======     $(this.GetFreshType())");
        def sameTyParLen = impl_meth.GetHeader().typarms.Length == fun_header.typarms.Length;

        if (sameTyParLen && ifaceType.TypeOfMember(impl_meth).TryUnify(this.GetFreshType()[0]))
            true
        else
        {
          //Message.Debug("fail");
          Util.locate(Location, MakeImplWrapper(ifaceType, impl_meth));
          false
        }
      }
      // we filter out interface methods, which we have implemented by means of
      // wrappers, the rest are ok to implement them directly
      this.ImplementedMethods = ImplementedMethods.Filter(is_correct_impl);
      // Message.Debug($"impl: $impl_list --> $thesame");
    }

    MakeImplWrapper(ifaceType : FixedType.Class, impl_meth : IMethod) : void
    {
      //assert2(ifaceType.tycon.Equals(declaring_type));
      assert2(declaring_type.IsDerivedFrom(ifaceType));
      // Message.Debug($"make impl wrap $this IMPL $impl_meth");
      def hd = impl_meth.GetHeader();
      def parms = hd.parms;
      mutable new_typarms = [];

      Util.cassert(Name.IndexOf('.') == -1, $"impl loop, $this IMPL $impl_meth, $(this.GetMemType()) != $(declaring_type.GetMemType().TypeOfMember(impl_meth))");

      def subst = impl_meth.DeclaringType.MakeSubst(ifaceType.args);
      //def subst = declaring_type.SubtypingSubst(impl_meth.DeclaringType);
      def orig_typarms = hd.typarms;
      //this.GetHeader().typarms;
      unless (orig_typarms.IsEmpty)
      {
        def (s2, newtp) = StaticTypeVar.CopyList(orig_typarms);
        //Message.Debug($"newtp: $orig_typarms -> $newtp");
        new_typarms = newtp;
        //Message.Debug($"subst before: $subst");
        subst.AddSubst(s2);
        NList.Iter2(fun_header.typarms, newtp,
                    (tv, repl) => subst.Add(tv, FixedType.StaticTypeVarRef(repl)));
        //Message.Debug($"subst after: $subst");
      }

      def parm_types_names = parms.Map(parm => (subst.Apply(parm.Type.Fix()), Macros.NewSymbol("sp_parm")));
      def formal_parms     = parm_types_names.Map((ty, name) => <[ parameter: $(name : name) : $(ty : typed) ]>);
      def name             = impl_meth.DeclaringType.FullName + "." + impl_meth.Name;

      declaring_type.forced_typarms = new_typarms;
      def meth =
        declaring_type.BindAndAddMember(<[ decl:
          private $(name : dyn)(.. $formal_parms) : $(subst.Apply(hd.ret_type.Fix()) : typed)
          {
          }
        ]>) :> IkvmMethodBuilder;
      //Message.Debug($"added $meth");
      meth.ImplementedMethods = [(ifaceType, impl_meth)];
      meth.Attributes |= NemerleAttributes.SpecialName | NemerleAttributes.Sealed;

      unless (impl_meth.DeclaringType.IsInterface)
        meth.Attributes = NemerleAttributes.Public | NemerleAttributes.Override;

      Manager.MarkAsUsed(meth);

      def current_fun = meth.GetHeader();
      def refs = current_fun.parms.Map(
        fun (parm : TParameter)
        {
          def val =
            Manager.Backend.CreateLocalValue(current_fun, parm.Name, parm.Type,
                        LocalValue.Kind.FunParm(ParmKind.Normal),
                        isMutable = false);
          val.Register();
          val.UseFrom(current_fun);
          parm.Decl = val;
          TExpr.LocalRef(val.Type, val)
        });

      def casted_refs = refs.Map(Parm);
      // def ty = subst.Apply(impl_meth.GetMemType());
      // def vars = new_typarms.Map(fun(x) { FixedType.StaticTypeVarRef(x) });
      def (the_method_type, vars) = ifaceType.TypeOfMethodWithTyparms(this); //!!!!
      NList.Iter2(new_typarms, vars, (x, tv) => tv.ForceUnify(FixedType.StaticTypeVarRef(x)));
      def (_, ret_type) = the_method_type.Fix().FunReturnTypeAndParms(this);
      //Message.Debug($"ty=$ty");

      def methref = TExpr.MethodRef(the_method_type, TExpr.This(declaring_type.GetMemType()),
                                    this, vars, !impl_meth.DeclaringType.IsInterface);

      // call the wrapped method,
      def body = TExpr.Call(ret_type, methref, casted_refs, false);
      //Message.Debug($"ty=$((this.ReturnType.Fix()))  $(subst.Apply(this.ReturnType.Fix()))");

      meth.GetHeader().body = FunBody.Typed(body);
      meth.GetHeader().typarms = new_typarms;

      def t4 = Typer4(meth);
      t4.Run();

      DeclaringType.TyManager.MaybeCompile(declaring_type, meth);
    }
  }
}