using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

namespace Nemerle.Statechart
{
  
  using FsmState;
  

  [Record]
  public variant IdType
  {
    | Int {val : uint;}
    | Long {val : ulong;}
    | Struct {val : BitArray;}
    | Class {val : BitArray;}
    
    public Id : ulong
    {
      get
      {
        match (this)
        {
          | Int(val) => val
          | Long(val) => val
          | _ => 0 : ulong
        }
      }
    }

    public IsSimple : bool
    {
      get
      {
        match (this)
        {
          | Int
          | Long => true
          | _ => false
        }
      }
    }
    
    engine : StateId;
    
    public Result : list[int]
    {
      get
      {
        match (this)
        {
          | IdType.Class(val)
          | Struct(val) => 
              def res = array(engine.Length);
              val.CopyTo(res, 0);
              res.NToList()
          | _ => []    
        }
        
      }
    }
    
  }

  using IdType;
  /// <summary>
  /// State identifier
  /// </summary>
  [Record]
  public class StateId
  {
    mutable analyser : FsmAnalyser;
    
    public this()
    {
    }
    
    [Accessor]
    mutable length : int;
    
    mutable count : int;
    
    [Accessor]
    mutable mask_type : IdType;
    
    
    //public static CreateNumId(st : FsmState) : void
    //{
    //  def st = st :: st.AllSubStates;//.Exclude(_ is ConcurrentSubRegion);
    //  st.IterI((i, s)  => s.Id.CreateNumId(i));
    //}
    
    //CreateNumId(i : int) : void
    //{
    //  Id = i :> ulong;
    //}
    
    
    CreateMask(parent : IdType, state : FsmState, analyser : FsmAnalyser) : void
    {
      //mask_type = type;
      this.analyser = analyser;
      def num = state.Num;//count - 1 - state.Num;
      
      def create_id(id1, id2 : BitArray)
      {
        def arr = BitArray(count);
        arr.Set(id1, true);
        if (id2 != null) arr.Or(id2) else arr
      }
        
      state.Id = match (mask_type, parent)
                 {
                   | (Int, null) => Int(this, 1U << num)
                   | (_, Int) when (num == 0) => Int(this, 0)
                   | (Int, Int(v)) => Int(this, (1U << num) | v)
                   | (Long, null) => Long(this, 1 : ulong << num)
                   | (_, Long) when (num == 0) => Long(this, 0)
                   | (Long, Long(v)) => Long(this, ((1 : ulong << num) | (v)))
                   | (Class, Class(v)) => Class(this, create_id(num, v))
                   | (Struct, Struct(v)) => Struct(this, create_id(num, v))
                 }
      
      def st = state.SubStates;
      st.Iter(CreateMask(state.Id, _, analyser));
    }
    
    public static CreateMasks(analyser : FsmAnalyser) : void
    {
      def st = analyser.Statemap.States;//.Filter(x => !(x is ConcurrentSubRegion));
      
      def count = st.Length;
      def length = MathUtils.UpperDiv(count, 32);
      def mask_type = match (length)
                  {
                    | x when x <= 1 => Int(null, 0)
                    | x when x <= 2 => Long(null, 0)
                    | x when x <= 4 => //LongId = BitArray(count);
                        Struct(null, null)
                    | _ => //LongId = BitArray(count);
                        Class(null, null)
                  }
      def stid = StateId(analyser, length, count, mask_type);
      stid.CreateMask(null, analyser.topState, analyser);
      //CreateMask(analyser, mask_type)
    }
    
  }
}
