using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using StateNode;
  using ListUtils;
  using GuardNode;
  /// <summary>
  /// Description of ParserActions.
  /// </summary>
  public partial class FsmParser
  {
    create_event(tok : NToken) : TransitionNode.Event
    {
      def name = GetText(tok);
      
      def name = match (name)
                 {
                   | "completion" 
                   | "_"  => null
                   | _  => name
                 }
      TransitionNode.Event(tok.StartPos, name)
    }

    create_guard(tok : NToken) : GuardNode
    {
      def cond = GetText(tok);
      def pos = tok.StartPos;
      match (cond)
      {
       | "else" => Else(pos)
       | _ => Guard(pos, cond)
      }
    }
    
    create_action(lst : List[NToken]) : Actions
    {
      def acts = lst |> GetText(_);
      Actions(acts)
    }

    CreateState(pos : int, name : string, attr : list[StateAttribute], decls : list[StateNode], type : StateType) : StateNode.State
    {
      def check_history(st, h)
      {
        match (h)
        {
          | StateNode.History(state = null) => def h = h.ChangeState(st);check_history(st, h)
          | History(default = Some(StateNode.Default(pos = p, history = History(state = null) as h) as tr)) as ph => ph.ChangeDefault(tr.Change(p, ph))
          | x => x
        }
      }

      def check_init(state, tr)
      {
        match (tr)
        {
          | Initial(to = History(History(state = null) as t) as tar) as tr    => tr.ChangeTarget(tar.Change(check_history(state, t)))
          | Initial(to = PseudoState(PseudoStateAstNode where (state = null) as t) as tar) as tr => tr.ChangeTarget(tar.Change(t.ChangeState(state)))
          | x  => x
        } 
      }
      
      def check_tran(state, tr)
      {
        match (tr)
        {
          | StateNode.Transition(to = State(st) as t) as tr when st.name == "@" ||  st.name == "self"  => tr.ChangeTarget(t.Change(state));
          | Transition(to = History(History(state = null) as t) as tar) as tr => tr.ChangeTarget(tar.Change(check_history(state, t)))
          | Transition(to = PseudoState(PseudoStateAstNode where (state = null) as t) as tar) as tr => tr.ChangeTarget(tar.Change(t.ChangeState(state)))
          | x  => x
        } 
      }

      def check_pseudo(st, ps)
      {
        match (ps)
        {
          | StateNode.PseudoState(node = PseudoStateAstNode where (state = null) as n) as ps => ps.Change(n.ChangeState(st))
          | x => x
        }
      }
          
      def get_decls(decls) 
      {
        def (en, decls) = decls.PartitionType();
        def (ex, decls) = decls.PartitionType();
        def (states, decls) =  decls.PartitionType();
        def (trans, decls)  =  decls.PartitionType();
        def (in_trans, decls) = decls.PartitionType();
        def (do_act, decls) = decls.FindType();
        def (init, decls) = decls.PartitionType();
        def (hist, decls) = decls.PartitionType();
        def (pseudo, decls) = decls.PartitionType();
        //def en_acts =  en |>< action.actions;
        //def ex_acts =  ex |>< action.actions;
        //def en = if (!en.IsEmpty()) option.Some(StateNode.Entry(en_acts)) else option.None();
        //def ex = if (!ex.IsEmpty()) option.Some(StateNode.Exit(ex_acts)) else option.None();
        def history = match (hist) 
                      {
                        | [head]  => TwoOption.One(head)
                        | [f, s]  => TwoOption.Two(f, s)
                        | _  => TwoOption.None() // TODO: надо отслеживать ошибку и выдавать пользователю
                      }
        (en, ex, states, trans, in_trans, do_act, init, history, pseudo, decls)
      } 
      
      def create_sub_regions(reg)
      {
        
        def (en, ex, states, trans, in_trans, do_act, init, hist, pseudo, _) = get_decls(reg);
        State(0, null, init, [], en, ex, in_trans, trans, do_act, hist, states, None(), pseudo, StateType.SubRegion(), [])
      }
      
      def decls = decls.Sort((x, y)  => x.pos - y.pos);
      def (reg_trans, reg) = decls.Partition(_ is StateNode.Transition);
      def regions = reg.FindDelimited(_ is State(type = StateType.SubRegion)); // split list by regions
      def (regions, decls) = if (regions.IsEmpty()) ([], decls) else (regions.Map(create_sub_regions), reg_trans); // create regions
      def (en, ex, states, trans, in_trans, do_act, init, hist, pseudo, decls) = get_decls(decls);
      def regions = match (regions)
                    {
                      | []  => None() // if no regions
                      | lst  => Some(Region(0, lst, State(name), trans)) // if some create node
                    }
      def st = State(pos, name, init, attr, en, ex, in_trans, trans, do_act, hist, states, regions, pseudo, type, decls |> Error(_.pos, _));
      //states.Iter(x => x.SuperState = st);
      //def trans = trans &+ init;
      
      def trans  = trans |> check_tran(st, _);
      def init   = init.Map(check_init(st, _));
      def hist   = hist.Map(check_history(st, _));
      def pseudo = pseudo.Map(check_pseudo(st, _));
      State(pos, name, init, attr, en, ex, in_trans, trans, do_act, hist, states, regions, pseudo, type, decls |> Error(_.pos, _));
      }

    def_history(hist : HistoryType, tok : NToken, tran : option[StateNode.Default]) : StateNode.History
    {
      def pos = tok.StartPos;
      
      def check_tran(t)
      {
        t.Change(pos, StateNode.History(tok.StartPos, null))
      }
      
      StateNode.History(tok.StartPos, hist, tran.Map(check_tran))
    }
    
  }
}
