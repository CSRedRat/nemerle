using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Core
{
  macro sizeof(type : PExpr)
  {
    sizeofImpl.DoTransform(Macros.ImplicitCTX(), type)
  }
  
  module sizeofImpl
  {
    public DoTransform(typer : Typer, type : PExpr) : PExpr
    {
      Macros.DefineCTX(typer);
      def buildin = typer.InternalType;
      def ty = typer.BindFixedType(type);
      
      if      (ty.Equals(buildin.SByte) || ty.Equals(buildin.Byte)   || ty.Equals(buildin.Boolean)) <[ 1 ]>
      else if (ty.Equals(buildin.Int16) || ty.Equals(buildin.UInt16) || ty.Equals(buildin.Char))    <[ 2 ]>
      else if (ty.Equals(buildin.Int32) || ty.Equals(buildin.UInt32) || ty.Equals(buildin.Single))  <[ 4 ]>
      else if (ty.Equals(buildin.Int64) || ty.Equals(buildin.UInt64) || ty.Equals(buildin.Double))  <[ 8 ]>
      else Message.FatalError(type.Location, "`sizeof' of `$type' unsupported yet")
    }
  }
}
