using Nemerle.IO;

class A {}
class B : A {}

class M
{
  static g(b : B) : A { (b : A) }        // OK
  static f() : int { ("foo" : int) }    // E: expected int.*, got string in type-enforced expression
}

enum Fruit { | Apple | Orange };

module M1 {
  // bug #753
  Foo() : list[string] // E: array.* is not a subtype of list.*
  {
     if (true) array(0) else null
  }

  f() : void
  {
    def f1 (x) { printf ("%s\n", x) };
    printf ("%d", f1 ("foo")); // E: expected int.*, got void in type-enforced expression
    f1 (3); // E: in argument #1 \(x\).*, needed a string.*, got int

    _ = null : System.Int32; // E: expected int.*, got .* in type-enforced expression.*null

    _ = $ "$(foo"; // E: no closing bracket found in `\(foo' \(the closing bracket in format string is probably missing\)
    _ = $ "$(foo +)"; // E: parse error near operator
    _ = $ "$()"; // E: expression without content
    _ = $ ""; // W: empty spliced string
    _ = $ " foo "; // W: spliced string without splices: ' foo '
  }

  g1() : void
  {
    if (true)
      null         // W: ignored computed value of type
    else
      Fruit.Apple; // W: ignored computed value of type Fruit
  }
  
  g2() : void
  {
    _ =
      if (true)
        Fruit.Apple
      else
        null; // E: Cannot implicitly convert type 'object\+' to 'Fruit.'

    _ =
      if (true)
        null
      else
        Fruit.Apple; // E: Cannot implicitly convert type 'Fruit' to '.+'

    def _x : Fruit =
      if (true)
        null // E: Cannot implicitly convert type 'object\+' to 'Fruit.'
      else
        Fruit.Apple;
  }
}
