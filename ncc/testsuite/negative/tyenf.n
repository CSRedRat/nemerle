using Nemerle.IO;

class A {}
class B : A {}

class M
{
  static g(b : B) : A { (b : A) }        // OK
  static f() : int { ("foo" : int) }    // E: expected int.*, got string in type-enforced expression
}

enum Fruit { | Apple | Orange };

module M1 {
  // bug #753
  Foo() : list[string] // E: array.* is not a subtype of list.*
  {
     if (true) array(0) else null
  }

  f() : void
  {
    def f1 (x) { printf ("%s\n", x) };
    printf ("%d", f1 ("foo")); // E: expected int.*, got void in type-enforced expression
    f1 (3); // E: in argument #1 \(x\).*, needed a string.*, got int

    _ = null : System.Int32; // E: expected int.*, got .* in type-enforced expression.*null

    _ = $ "$(foo"; // E: no closing bracket found in `\(foo' \(the closing bracket in format string is probably missing\)
    _ = $ "$(foo +)"; // E: parse error near operator
    _ = $ "$()"; // E: expression without content
    _ = $ ""; // W: empty spliced string
    _ = $ " foo "; // W: spliced string without splices: ' foo '
  }

  g() : void
  {
    _ =
      if (true) // E: typing fails on delayed typing of conditional expression computation branchs
        Fruit.Apple // E: Type of this computation branch \(Fruit\) is incompatible with type \(object\+\) of other branch
      else
        null; // E: Type of this computation branch \(object\+\) is incompatible with type \(Fruit\) of other branch
    _ =
      if (true) // E: typing fails on delayed typing of conditional expression computation branchs
        null // E: Type of this computation branch \(object\+\) is incompatible with type \(Fruit\) of other branch
      else
        Fruit.Apple; // E: Type of this computation branch \(Fruit\) is incompatible with type \(object\+\) of other branch
  }
}
