using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{
  
  using StateNode;
  
  public enum HistoryType
  {    
    | None
    | Shallow
    | Deep
  }   
     
  [Record]
  public variant NameIdentifier
  {
    | Name 
    | QualifiedName 
    {
      parts : list[string];
    }
        
    public pos : int;
    public name : string;
    
    public TargetName : string
    {
      get
      {
        match (this)
        {
          | NameIdentifier.Name(name = n)
          | QualifiedName(name = n)  => n
        }
      }
    }
    
    public ParentName : string
    {
      get
      {
        match (this)
        {
          | NameIdentifier.Name  => null
          | QualifiedName(name = n)  => n
        }
      }
    }
    
    public GetState() : State
    {
      def n = ParentName;
      if (n == null) null else State(n)
    }
        
    public GetNode() : State
    {
      State(TargetName)
    }
  }
  
  [Record]
  public variant GuardNode
  {
    | Guard {condition : string;}
    | InState {state : string;}
    | Else
    
    public pos : int;
    public override ToString() : string {Name}
          
    public Name : string
    {
      get
      {
        match (this)
        {
          | Guard(c) => $"GuardNode$c"
          | InState(c) => $"InState$c" 
          | Else => "Else"
        }
      }
    }
        
    public CompareTo(b : GuardNode) : int
    {
      match (this, b)
      {
        | (Guard(a), Guard(b))
        | (InState(a), InState(b)) => a.CompareTo(b)
        | (_, _) => -1
      }
    }
  }
  
  [Record]
  public variant TransitionNode
  {      
    | Event 
        {
          name : string; 
          
          override ToString() : string {name}
        }      
    | JunctionNode
        {
          GuardNode : option[GuardNode];
          action : option[Actions];
          to : TargetType;
        }
    
    
    public pos : int {get;set;}
  }
  
  [Record]
  public variant StateAttribute
  {
    | None
    | Initial 
    | Unknown {name : string}
    
    [Accessor]
    pos : int
  }
  
  [Flags]
  public enum MachineFlag
  {
    | None    
    | Debug                = 0b0001 // enable debug point
    | AutoInitial          = 0b0010 // automatic define initial transition in first defined sub state
    | LocalDefault         = 0b0100 // local transitions by default rather than external
    | TransitionCompleted  = 0b1000 // create TransitionCompleted events
  }
  
  [Record]
  public class MachineFlags
  {
    [FlagAccessor (AutoInitial, LocalDefault, Debug, TransitionCompleted, flags = WantSetter)]
    mutable flags : MachineFlag;
   
   
  }
  
  [Flags]
  public enum ActionFlags
  {
    | None
    | PreSet = 0b0001;// means that entry action of state is run after state is entered and set as current
  }
  
  [Flags]
  public enum ActivityFlag
  {
    | None
    | Concurrently = 0b0001 // run several activities concurrently in separate task
    | NoWaitCancel = 0b0010 // no wait of canceling activity
    | NotLong      = 0b0100 // this is not long activity (eg fast action), this implies that parallel task create with specific option, 
                            // prevents long activity in the planner see TaskCreationOptions.LongRunning (this is default for activities)
  }
  
  [Record]
  public variant PseudoStateAstNode
  {      
    | Fork {target : list[TargetType];}
    | Join {name : string;target : TargetType;}
    | Junction
        {
          mutable name : string;
          nodes : list[TransitionNode.JunctionNode];
      
          Name : string
          {
            get
            {
              if (name !=null) $"Junction$name" else "UnnamedJunction"
            }
          }
      
          override ToString() : string {Name}
        }
    | Choice
        {
          mutable name : string;
          nodes : list[TransitionNode.JunctionNode];
      
          Name : string
          {
            get
            {
              if (name !=null) $"Choice$name" else "UnnamedChoice"
            }
          }
      
          override ToString() : string {Name}
        }
    | Merge
        {
          name : string;
          node : TransitionNode.JunctionNode;
        }
    | EntryPoint
    | ExitPoint
    | Terminate 

    public mutable state : State;
    public pos : int {get;set;}
  }
  
  [Record]
  public variant TargetType
  {
    | History
        {
          history : StateNode.History;
          
          this(pos : int, state : StateNode.State)
          {
            history = StateNode.History(pos, state);
            base(pos);
          }
        }
    | PseudoState {node : PseudoStateAstNode;}
    | Final {node : StateNode.Final;}
    | State {mutable state : StateNode.State;}
    | Named {parent : StateNode.State;name : string;}
    | SubMachine {machine : StateNode.State;state : string;}
    | Qualified {parent : string;target : TargetType;}
    
    public pos : int;
  }
  
}
