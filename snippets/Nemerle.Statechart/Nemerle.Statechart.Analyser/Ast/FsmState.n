using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Reflection;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;
  
  [Record]
  [DebuggerDisplay("State  =  {Name}")]
  public partial variant FsmState
  {
    | State  
        {
          
          //public this(st : StateNode.State, reference : bool)
          //{
          //  base(st, reference)
          //}
          
          this(name : string)
          {
            this(StateNode.State(name), true)
          }
          
        }
        
    | Final
        {
          this(st : Final, reference : bool = false, clone : bool = false)
          {
            base(st, reference, clone);
            completion = st.completion;
          }
          
          [Accessor(flags = WantSetter)]
          mutable completion : list[StateTransition] = [];
          
          this(super : FsmState, reference : bool =  false)
          {
            base();
            this.super_state = super;
            name =  $"$(super_state)Final";
            this.reference = reference;
          }

          //override UpdateReference(map : StateMap) : void
          //{
          //  Analyser = map.Analyser;
          //  when (super_state.Reference) super_state = map[super_state.name];
          //}
        }

    | ConcurrentSubRegion
        {
          index : int;
          contained_in : ConcurrentRegion;
      
          this(st : ConcurrentSubRegion, clone : bool = false)
          {
            base(st, false, clone);
            index = st.index;
            contained_in = st.contained_in;
          }
          
          this(region : ConcurrentRegion, st : StateNode.State, idx : int)
          {
            contained_in = region;
            do_activity = st.do_activity |> StateAction.Do(_.action.ActionList, this, _.flags);
            internal_tran = Internal.Create(this, st.internal_tran);
            entry = st.entry |> StateAction.Entry(_.action.ActionList, this);
            exit = st.exit |> StateAction.Exit(_.action.ActionList, this);
            history = StateHistory.Create(this, st.history);
            transitions = Transition.Create(this, st.transitions);
            initial = st.initial |> Initial(this, _);
            pseudo_states = st.pseudo_states |> PseudoStateNode.Create(_.node);
            sub_states = st.sub_states |> State(_, false);
            sub_states.Iter(x => x.super_state = this);
            index = idx;
            super_state = region;
          }
    
          transitions_to_final : list[StateTransition]
          {
            get
            {
              (LivedSubStatesNested |>< transitions).Filter(x => x.ActualTo is Final)
            }
          }
          
          FinalState : option[FsmState]
          {
            get
            {
              sub_states.Find(_ is Final)
            }
          }
        }
    
    | ConcurrentRegion
        {
          sub_regions : list[ConcurrentSubRegion] = [];
    
          mutable exit_pattern : Map[string, list[ConcurrentSubRegion]] = Map();
          mutable enter_pattern : Map[string, list[ConcurrentSubRegion]] = Map();
    
          /// <summary>
	        /// Indicates that maybe external transitions from some points of orthogonal state out of region not only completion
	        /// </summary>
          MayTakePlaceForcedTransitions : bool {get;set;}
          NeedHistorySave : bool {get;set;}
          /// <summary>
		      /// Indicates that maybe transitions from outer states forking control to this orthogonal region
		      /// </summary>
          MayForkingFromOut : bool {get;set;}
          
          this(st : ConcurrentRegion, clone : bool = false)
          {
            base(st, false, clone);
            sub_regions = st.sub_regions;
            exit_pattern = st.exit_pattern;
            enter_pattern = st.enter_pattern;
            MayTakePlaceForcedTransitions = st.MayTakePlaceForcedTransitions;
            NeedHistorySave = st.NeedHistorySave;
            MayForkingFromOut = st.MayForkingFromOut;
          }
          
          this(st : FsmState, node : StateNode.Region)
          {
            name = node.state.name;
            super_state = st;
            transitions = Transition.Create(this, node.transitions);
            sub_regions = node.regions.MapIndex((x, i) => ConcurrentSubRegion(this, x, i));
            sub_states = sub_regions |> _ : FsmState;
          }

          static get_pattern(reg : list[ConcurrentSubRegion]) : string
          {
            def idx = (reg |> index).Sort(_ - _);
            $<#..$(idx;"")#>; //idx |> ToString();
            //string.Join("", idx)
          }
          
          DefineExitPattern(reg : list[ConcurrentSubRegion]) : void
          {
            def str = get_pattern(reg);
            when (!exit_pattern.Contains(str)) exit_pattern = exit_pattern.Add(str, reg);
          }
          
          DefineEnterPattern(reg : list[ConcurrentSubRegion]) : void
          {
            def str = get_pattern(reg);
            when (!enter_pattern.Contains(str)) enter_pattern = enter_pattern.Add(str, reg);
          }

          RegionExcept(st : list[ConcurrentSubRegion]) : ConcurrentSubRegion
          {
            match (sub_regions.Exclude(st, _ == _))
            {
              | [sub] => sub
              | head :: _ => head
              | _ => null
            }
          }

          RegionsExcept(st : list[FsmState]) : list[ConcurrentSubRegion]
          {
            sub_regions.Filter(x => !x.AllSubStates.Exists(y => st.Exists(y == _)) && !st.Exists(_ == x))
          }
          
          RegionsExcept(st : FsmState) : list[ConcurrentSubRegion]
          {
            sub_regions.Filter(x => !x.AllSubStates.Contains(st) && x != st)
          }

          Joins : list[PseudoStateNode.Join]
          {
            get
            {
              def get_join(t, lst)
              {
                match (t)
                {
                  | StateTransition where (To = TransitionTarget.PseudoState(Join() as j)) => j :: lst
                  | _ => lst
                }
              }
      
              def tran = AllLivedSubStatesNested.Map(x => x.all_transitions.FoldLeft([], get_join)).Flatten();
              tran.RemoveDuplicatesSort((x, y) => FsmAnalyser.StringComparator(x.name, y.name));
            }
          }
          
          HaveJoinTransitions : bool
          {
            get
            {
              !Joins.IsEmpty()
            }
          }
          
          HaveFinalCompletion : bool
          {
            get
            {
              def st = this :: SuperStates;
              HaveFinal && st.Exists(x => !x.completion_transitions.IsEmpty())
            }
          }
          
          
          FinalStates : list[FsmState]
          {
            get
            {
              if (HaveFinal) sub_regions |> FinalState.Value else []
            }
          }
          
        }
   
    | SubMachine
        {
          type : string;
      
          mutable ref_sub_states : list[string] = [];
          mutable proc_events : list[string] = [];
          private mutable scanned : bool;
          mutable inlined : bool;
          mutable inlined_st : FsmState.InlinedSubMachine;
          
          this(st : SubMachine, clone : bool = false) 
          {
            base(st, false, clone);
            type = st.type;
            ref_sub_states = st.ref_sub_states;
            proc_events = st.proc_events;
            scanned = st.scanned;
            inlined = st.inlined;
          }
          
          this(st : StateNode.State)
          {
            def (StateNode.State(type = StateType.SubMachine(type = t))) = st;
            name = st.name;
            this.type = t;
            super_state = State(st.SuperState, true);
            transitions = Transition.Create(this, st.transitions);
          }
      
          Scan() : void
          {
            when (!inlined && !scanned)
            {
              def type = Type.GetType(type);
              def st = type.GetField("ContainsStates");
              ref_sub_states = st.GetValue(null) :> list[string];
              def evt = type.GetField("ProcessEvents");
              proc_events = evt.GetValue(null) :> list[string];
              scanned = true;
            }
          }
          
          
          InitInline() : void
          {
            def update_pseudo(tar, _, new_st)
            {
              match (tar)
              {
                | TransitionTarget.PseudoState(node) as t when (node == new_st) => t.node = new_st
                | _ => ()
              }
              null
            }

            def st = inlined_st.Clone();
            do_activity = st.do_activity;
            internal_tran = st.internal_tran;
            entry = st.entry;
            exit = st.exit;
            history = st.history;
            initial = st.initial;
            sub_states = st.sub_states;
            def tran = st.all_transitions_nested;
            def tran = tran %+ st.AllHistory.FilterValues(_.Default);
            def ren_st = st.AllSubStates |> (CloneFor, _);
            def pst = st.AllPseudoStates |> (CloneFor, _);
            sub_states.Iter(x => x.super_state = this);
            pst.Iter((ost, nst) => tran.Iter(x => x.TargetTraverse(update_pseudo(_, ost, nst))));
            ren_st.Iter((ost, nst) => tran.Iter(x => x.UpdateTargets(ost, nst)));
            st.AllSubStates.Iter(x => x.history.Iter(x => x.reference = true));
            pseudo_states = st.pseudo_states;
            UpdateReference(Analyser.Statemap);
            AllSubStates.Iter(x => x.UpdateReference(Analyser.Statemap));
          }
          
          override UpdateReference(map : StateMap) : void
          {
            base.UpdateReference(map);
            when (!inlined)
            {
              def fsm = map.States.FilterType();
              match (fsm.Find(x => x.type == type))
              {
                | Some(InlinedSubMachine as f) => 
                    inlined = true;
                    inlined_st = f
                | _ => ()
              }
            }
          }

        }
    
    | InlinedSubMachine
        {
          type : string;
      
          [RecordIgnore] mutable ncopy : int;
          
          this(st : InlinedSubMachine, clone : bool = false) 
          {
            when (clone) 
            {
              st.ncopy++;
              ncopy = st.ncopy;
            }
            base(st, false, clone, ncopy);
            type = st.type;
          }
          
          this(st : StateNode.State, reference : bool = false)
          {
            base(st, reference);
            def (StateNode.State(type = StateType.InlinedSubMachine(type = t))) = st;
            this.type = t;
          }
        
        }  
  }

}
