using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using FsmState;
  
  [Record]  
  public class StateEvent
  {
    [Accessor] evt : TransitionNode.Event;
    public InternalOnly : bool {get;set;}

    public Name : string
    {
      get
      {
        if (evt.name != null) evt.name else "Completion"
      }
    }

    public this(e : TransitionNode.Event)
    {
      evt = e;
    }

    public CompareTo(b : StateEvent) : int
    {
      FsmAnalyser.StringComparator(Name, b.Name)
    }

    public static  @== (a : StateEvent, b : StateEvent) : bool
    {
      FsmAnalyser.StringComparator(a.Name, b.Name) == 0
    }

    public IsCompletion : bool
    {
      get
      {
        evt.name == null
      }
    }
    
    public override ToString() : string
    {
      $"Event$Name"
    }
  }
  
  public variant StateHistory
  {
    | Shallow
        {
          public this(st : FsmState,  hist : StateNode.History, reference : bool = false)
          {
            history = hist;
            state = if (hist.state != null) FsmState.State(hist.state, true); else st;
            type = hist.type;
            this.reference = reference;
            default = history.default |> StateTransition.Default(state, this, _);
          }
      
        }
    | Deep
        {
          public this(st : FsmState,  hist : StateNode.History, reference : bool = false)
          {
            history = hist;
            state = if (hist.state != null) FsmState.State(hist.state, true); else st;
            type = hist.type;
            this.reference = reference;
            default = history.default |> StateTransition.Default(state, this, _);
          }
      
        }
      
    [Accessor] mutable history : StateNode.History;
    [Accessor] mutable default : option[StateTransition.Default];
    public state : FsmState {get;set;}
    [Accessor] mutable type : HistoryType;
    public reference : bool {get;set;}
          
    public Used : bool {get;set;}
    public Index : int {get;set;}
    
    public this() {}
    public this(hist : StateHistory, clone : bool = false, ncopy : int = 0)
    {
      history = hist.history;
      default = if (clone) hist.default.Map(x => x.Clone(ncopy) :> StateTransition.Default) else hist.default;
      state = hist.state;
      type = hist.type;
      reference = hist.reference;
      Used = hist.Used;
      Index = hist.Index;
    }
    
    public static Create(st : FsmState, hist : TwoOption[StateNode.History], href : bool = false) : TwoOption[StateHistory]
    {      
      hist.Map(Create(st, _, href))
    }

    public static Create(st : FsmState, hist : StateNode.History, href : bool = false) : StateHistory
    {
      match (hist)
      {
        | StateNode.History(type = HistoryType.Deep)    => StateHistory.Deep(st, hist, href)
        | StateNode.History(type = HistoryType.Shallow) => StateHistory.Shallow(st, hist, href)
        | _ => null
      }
    }
    
    public Clone(ncopy : int) : StateHistory
    {
      def newh = match (this)
                 {
                   | Shallow as h => Shallow(h, true, ncopy)
                   | Deep    as h => Deep(h, true, ncopy)
                 }
      newh.clone_for = this;
      newh
    }
    
    [Accessor] mutable clone_for : StateHistory;
    
    public static  @==(a : StateHistory, b : StateHistory) : bool
    {
      | (null, null)  => true
      | (a, null)  => a : object  ==  null
      | (null, b)  => b : object  ==  null
      | (_, _)  => a.Name == b.Name && a.type == b.type && a.state == b.state
    }

    public static @!=(a : StateHistory, b : StateHistory) : bool
    {
            !(@==(a, b))
    }
          
    public BothHistories : bool
    {
      get
      {
        state.BothHistories
      }
    }
    
    public Name : string
    {
      get
      {
        def type = match (type)
                   {
                     | Deep  => "Deep"
                     | Shallow  => "Shallow"
                     | None  => ""
                   }
                  
        if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
      }
    }
    
    public SimpleName : string
    {
      get
      {
        $"$(state)History"
      }
    }
    
    public override ToString() : string
    {
      Name
    }
    
    public SubStatesParticipateInHistory : list[FsmState]
    {
      get
      {
        state.SubStatesParticipateIn(this)
      }
    }

    public UpdateReference(map : StateMap) : void
    {
      when (state.Reference) state = map[state.Name];
      when (history.reference)
      {
        def hist  =  state.GetHistory(this);
        type  =  hist.type;
        default  =  hist.default;
      }
      default.Iter(_.UpdateReference(map));
    }
    
  }
    
  [Record]
  public variant PseudoStateNode
  {
    | Junction
        {
          mutable name : string;
          nodes : list[JunctionNode];
          parent : Junction;
          
          this(st : FsmState, n : string, lst : list[TransitionNode.JunctionNode])
          {
            base(st);
            nodes = lst |> JunctionNode(st, null, _, this);
            name = n;
          }
          
          
          Name : string
          {
            get
            {
              $"Junction$name$copy_name"
            }
          }
          
          [RecordIgnore]
          DecisionTree : DecisionNode {get;set;}
          
          IsTop : bool 
          {
            get
            {
              parent == null
            }
          }
          
          Guards : list[GuardNode]
          {
            get
            {
              def g = nodes.FoldLeft([], (x, a) => a + x.Guards).Rev();
              g.Exclude(_ is GuardNode.Else)
            }
          }
          
          Paths : PathNode
          {
            get
            {
              DecisionTree.Paths
            }
          }
          
          override UpdateReference(map : StateMap) : void
          {
            nodes.Iter(_.UpdateReference(map));
            base.UpdateReference(map)
          }
          
          override ToString() : string
          {
            Name
          }
          
        }
    | Choice
        {
          mutable name : string;
          nodes : list[JunctionNode];
          parent : Choice;
          
          this(st : FsmState, n : string, lst : list[TransitionNode.JunctionNode])
          {
            base(st);
            nodes = lst |> JunctionNode(st, null, _, this);
            name = n;
          }
          
          [RecordIgnore]
          DecisionTree : DecisionNode {get;set;}
          
          IsTop : bool 
          {
            get
            {
              parent == null
            }
          }
          
          Guards : list[GuardNode]
          {
            get
            {
              def g = nodes.FoldLeft([], (x, a) => a + x.Guards).Rev();
              g.Exclude(_ is GuardNode.Else)
            }
          }
          
          Paths : PathNode
          {
            get
            {
              DecisionTree.Paths
            }
          }
          
          public override UpdateReference(map : StateMap) : void
          {
            nodes.Iter(_.UpdateReference(map));
            base.UpdateReference(map)
          }
          
          Name : string
          {
            get
            {
              $"Choice$name$copy_name"
            }
          }
          
          override ToString() : string
          {
            Name
          }
      
        }
    
    | Merge
        {
          name : string;
          node : JunctionNode;

          this(st : FsmState, n : string, node : TransitionNode.JunctionNode)
          {
            base(st);
            this.node = JunctionNode(st, null, node,  this);
            name = n;
          }
          
          public override UpdateReference(map : StateMap) : void
          {
            node.UpdateReference(map);
            base.UpdateReference(map)
          }
       
          Name : string
          {
            get
            {
              $"Merge$name$copy_name"
            }
          }
          
          override ToString() : string
          {
            Name
          }
        }
    | Fork 
        {
          mutable target : list[TransitionTarget];
       
          [RecordIgnore] mutable fork_tran : list[StateTransition] = [];
          
          override UpdateReference(map : StateMap) : void
          {   
            target.Iter(_.UpdateReference(map));
            base.UpdateReference(map);
          }
          
          Name : string
          {
            get
            {
              $<#Fork$(state)To..$(target;"_")#>
            }
          }
          
          override ToString() : string
          {
            Name
          }
        }
    | Join 
        {
          name : string;
          mutable target : TransitionTarget;
          mutable region : ConcurrentRegion;
          [RecordIgnore] mutable joined_tran : list[StateTransition] = [];
          [RecordIgnore] mutable transition : StateTransition;
          
          trigger : StateEvent
          {
            get
            {
              match (joined_tran)
              {
                | [] => null
                | StateTransition where (Trigger = t) :: _ => t
              }
            }
          }
          
          Name : string
          {
            get
            {
              $"Join$name$copy_name"
            }
          }
          
          override ToString() : string
          {
            Name
          }

          override UpdateReference(map : StateMap) : void
          {
            target?.UpdateReference(map);
            base.UpdateReference(map);
          }
          
        }
    | EntryPoint
    | ExitPoint
    | Terminate
        {
          Name : string
          {
            get
            {
              $"$(state)Terminate"
            }
          }
          
          
          override ToString() : string
          {
            Name
          }
        }
    
    | JunctionNode
        {
          guard : option[GuardNode];
          action : option[Actions];
          [Accessor(flags = WantSetter)] mutable to : TransitionTarget;
          parent : PseudoStateNode;
          
          this(st : FsmState, tran : StateTransition, node : TransitionNode.JunctionNode, par : PseudoStateNode)
          {
            match (node)
            {
              | TransitionNode.JunctionNode(g, a, t) =>
        
                  base(st);
                  guard = g;
                  action = a;
                  parent = par;
                  to = TransitionTarget.Create(st, tran, t)
            }
          }
          
          Top : PseudoStateNode
          {
            get
            {
              def find_top(j)
              {
                | Junction(parent = null)
                | Choice(parent = null) => j
                | Junction(parent = p)
                | Choice(parent = p) => find_top(p)
                | _ => null
              }
              
              find_top(parent)
            }
          }
          
          Guards : list[GuardNode]
          {
            get
            {
              def g = match (to)
                      {
                        | TransitionTarget.PseudoState(Choice(Guards = g))
                        | TransitionTarget.PseudoState(Merge(node = JunctionNode(Guards = g)))
                        | TransitionTarget.PseudoState(Junction(Guards = g)) => g
                        | _ => []
                      }
              guard.MapDefault(x => g + [x], g)
            }
          }
          
          public override UpdateReference(map : StateMap) : void
          {      
            to.UpdateReference(map)
          }
          
        }
        
    public static Create(st : PseudoStateAstNode) : PseudoStateNode
    {
      match (st)
      {
        | Junction(state = st, name = n, nodes = lst) => def st = CreateState(st);
            Junction(st, n, lst)
        | Choice(state = st, name = n, nodes = lst) => Choice(CreateState(st), n, lst)
        | Merge(state = st, name = n, node = node) => Merge(CreateState(st), n, node)
        | Fork(target = lst, state = st) => Fork(CreateState(st), lst |> TransitionTarget.Create(State(st, true), null, _))
        | Join(state = null, name = n, target = _) => Join(null, n, null, null)
        | Join(state = st, name = n, target = t) => def st = State(st, true);
            Join(st, n, TransitionTarget.Create(st, null, t), null)
        | EntryPoint(state = st) => EntryPoint(CreateState(st))
        | ExitPoint(state = st) => ExitPoint(CreateState(st))
        | Terminate(state = st) => Terminate(CreateState(st))
      }
    }
        
    public Clone(ncopy : int) : PseudoStateNode
    {
      def npst = match (this)
                 {
                   | Junction(state = st, name = n, nodes = lst, parent = p) => Junction(st, n, lst |> (_.Clone(ncopy) :> JunctionNode), p)
                   | Choice(state = st, name = n, nodes = lst, parent = p) => Choice(st, n, lst |> (_.Clone(ncopy) :> JunctionNode), p)
                   | Merge(state = st, name = n, node = node) => Merge(st, n, node.Clone(ncopy) :> JunctionNode)
                   | Fork(target = lst, state = st) => Fork(st, lst)
                   | Join(state = st, name = n, target = t, region = r) => Join(st, n, t, r)
                   | EntryPoint(state = st) => EntryPoint(st)
                   | ExitPoint(state = st) => ExitPoint(st)
                   | Terminate(state = st) => Terminate(st)
                   | JunctionNode(state = st, guard = g, action = a, to = t, parent = p) => JunctionNode(st, g, a, t.Clone(ncopy), p)
                 }
      npst.cloneFor = this;
      npst.copy = ncopy;
      npst
    }
    
    copy_name : string
    {
      get
      {
        if (copy == 0) "" else $"$copy"
      }
    }
    
    public mutable state : FsmState;

    [RecordIgnore] [Accessor] mutable cloneFor : PseudoStateNode;
    [RecordIgnore] mutable copy : int;
    
    public NativeName : option[string]
    {
      get
      {
        match (this)
        {
          | Join(name = n) 
          | Choice(name = n)
          | Merge(name = n)
          | Junction(name = n) => Some(n)
          | _ => None()
        }
      }
    }
    
    public static @==(a : PseudoStateNode, b : PseudoStateNode) : bool
    {
      | (Join(state = st, name = null, target = t), Join(state = st2, name = null, target = t2)) => st == st2 && t == t2
      | (Junction(name = n), Junction(name = n2))
      | (Choice(name = n), Choice(name = n2))
      | (Join(name = n), Join(name = n2))
      | (Merge(name = n), Merge(name = n2)) => FsmAnalyser.StrEq(n, n2)
      | (Fork(target = lst, state = st), Fork(target = lst2, state = st2)) => st == st2 && lst.Equals(lst2, _ == _)
      | (EntryPoint(state = st), EntryPoint(state = st2))
      | (ExitPoint(state = st), ExitPoint(state = st2))
      | (Terminate(state = st), Terminate(state = st2)) => st == st2
      | _ => false
    }
    
    public virtual UpdateReference(map : StateMap) : void
    {
      when (state !=null && state.Reference) state = map[state.Name];
    }
    
  }
  
  [Record]    
  [DebuggerDisplay("Actions  =  {ActionList}")]
  public variant StateAction : Actions
  {
    | Entry
        {

          Name : string
          {
            get
            {
              $"$(state)Entry"
            }
          }
         
          override ToString() : string
          {
            Name
          }
        
        }
    | Exit
        {
          Name : string
          {
            get
            {
              $"$(state)Exit"
            }
          }
         
          override ToString() : string
          {
            Name
          }
        }
      
    | Do 
        {
          [FlagAccessor (Concurrently,  NoWaitCancel, NotLong, flags = WantSetter)]
          mutable flags : ActivityFlag; // shows that we must run each action concurrently with others
          
          Name : string
          {
            get
            {
              $"DoActivity$(state)"
            }
          }
         
          override ToString() : string
          {
            Name
          }
        }       
        
    public state : FsmState;
  }
  
}
