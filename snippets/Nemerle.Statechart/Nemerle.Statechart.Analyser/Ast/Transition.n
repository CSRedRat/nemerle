using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{  
  
    
  public partial variant StateTransition
  {
    | Default
        {
          default : StateNode.Default;
          history : StateHistory;
          
          this(tran : Default, clone : bool = false, ncopy : int = 0)
          {
            base(tran, clone, ncopy);
            default = tran.default;
            history = tran.history;
          }
          
          this(st : FsmState, hist : StateHistory, default : StateNode.Default)
          {
            this.default = default;
            history = hist;
            action = default.action;
            From = st;
            Source = From;
            To = TransitionTarget.State(this, FsmState.State(default.target, true))
          }
        }
        
    | Initial 
        {
          initial : StateNode.Initial;
          
          this(tran : Initial, clone : bool = false, ncopy : int = 0)
          {
            base(tran, clone, ncopy);
            initial = tran.initial;
          }
          
          this(st : FsmState, init : StateNode.Initial)
          {
            From = st;
            Source = From;
            guard = init.guard;
            action = init.action;
            To =  TransitionTarget.Create(st, this, init.to);
          }
          
          this(from : FsmState, to : FsmState)
          {
            From = from;
            Source = From;
            To = TransitionTarget.State(this, to);
          }
          
        }
        
    [DebuggerDisplay("Transition  =  {Name}")]
    | Transition 
        {
          trigger : StateEvent;
          node : StateNode.Transition;
          
          TriggerName : string
          {
            get
            {
              trigger.Name
            }
          }

          static Create(st : FsmState, tr : list[StateNode.Transition]) : list[StateTransition]
          { 
            $[Transition(st, StateEvent(y), x) : StateTransition, x in tr, y in x.evt]
          }

          this(tran : Transition, clone : bool = false, ncopy : int = 0)
          {
            base(tran, clone, ncopy);
            trigger = tran.trigger;
            node = tran.node;
          }
          
          this(st : FsmState, evt : StateEvent, tr : StateNode.Transition)
          {
            From = st;
            Source = From;
            this.trigger = evt;
            node = tr;
            guard = tr.guard;
            action = tr.action;
            To = TransitionTarget.Create(st, this, tr.to)
          }

          this(st : FsmState, to : FsmState, source : PseudoStateNode)
          {
            From = st;
            Source = From;
            ImplicitFrom = source;
            To = TransitionTarget.State(this, to);
          }
          
          this(st : FsmState, trigger : StateEvent, to : TransitionTarget, source : PseudoStateNode)
          {
            From = st;
            this.trigger = trigger;
            Source = From;
            ImplicitFrom = source;
            To = to;
          }
          
          this(st : FsmState, tr : Transition)
          {
            this(tr, true);
            Source = st;
          }
        }
        
    | Internal
        {
          trigger : StateEvent;
          node : StateNode.InternalTransition;
          
          ActionNode : PathNode
          {
            get
            {
              PathNode.Action(action.Value)
            }
          }

          TriggerName : string
          {
            get
            {
              trigger.Name
            }
          }

          override ToString() : string
          {
            Name
          }

          this(tran : Internal, clone : bool = false, ncopy : int = 0)
          {
            base(tran, clone, ncopy);
            trigger = tran.trigger;
            node = tran.node;
          }
          
          this(st : FsmState, tr : Internal)
          {
            this(tr);
            Source = st;
          }
          
          this(trigger : StateEvent, tran : StateNode.InternalTransition, from : FsmState) 
          {
            this.trigger = trigger;
            node = tran;
            action = Some(node.action);
            guard = node.guard;
            From = from;
            Source = from;
          }

          static Create(st : FsmState, tr : list[StateNode.InternalTransition]) : list[StateTransition]
          {
              $[Internal(StateEvent(y), x, st) : StateTransition, x in tr, y in x.evt]
          }
          
        }
        
    | History
        {
          history : StateHistory;
          
          this(tran : History, clone : bool = false, ncopy : int = 0)
          {
            base(tran, clone, ncopy);
            history = tran.history;
          }
          
          this(hist : StateHistory, st : FsmState, to : FsmState)
          {
            From = st;
            history = hist;
            Source = From;
            To = TransitionTarget.State(this, to);
          }
        
        }
  }
  
  [Record]
  public variant DecisionNode
  {
    | Condition 
        {
          condition : GuardNode;
          body : DecisionNode;
          else_node : DecisionNode;
          
          this(c : Condition)
          {
            base(c);
            condition = c.condition;
            body      = c.body;
            else_node = c.else_node;
          }
        }
    | Action
        {
          condition : option[GuardNode];
          body : DecisionNode;
          
          this(c : DecisionNode.Action)
          {
            base(c);
            condition = c.condition;
            body      = c.body
          }
        }
    | Else
        {
          body : DecisionNode;
          
          this(c : Else)
          {
            base(c);
            body = c.body
          }
        }
    | Target 
        {
          target : TransitionTarget;
          [RecordIgnore] mutable destination : TransitionDestination;
          
          this(c : Target, clone : bool, ncopy : int = 0)
          {
            base(c);
            target = if (clone) c.target.Clone(ncopy) else c.target
          }
        }
    //| Error
      
    public this(node : DecisionNode)
    {
      NodePath = node.NodePath;
      OutPath  = node.OutPath;
      level    = node.level;
      state    = node.state;
    }
    
    public level : int;
        
    public state : FsmState;
    
    public Paths : PathNode
    {
      get
      {
        match (this)
        {
          //| Error
          //| null => PathNode.Empty()
          | Condition(body = b, else_node = null, Path = p) => p + b.Paths
          | Condition(body = b, else_node = els, Path = p) => p + b.Paths + els.Paths
          | Else(body = b, Path = p) => p + b.Paths
          | Action(Path = p) => p
          | Target(Path = p) => p
        }
      }
    }
        
    public actions : list[Actions];
        
    public ThisPath : PathNode
    {
      get
      {
        actions.FoldLeft(PathNode.Empty(), (x, a) => a + PathNode.Action(x));
      }
    }
    
    [RecordIgnore] public mutable NodePath : PathNode = PathNode.Empty();
    [RecordIgnore] public mutable OutPath : PathNode = PathNode.Empty();

    [RecordIgnore] public ThisOutPath : PathNode
    {
      get
      {
        ThisPath + OutPath
      }
    }
   
    
    [RecordIgnore] public Path : PathNode
    {
      get
      {
        NodePath + ThisPath + OutPath
      }
    }
   
    public Clone() : DecisionNode
    {
      match (this)
      {
       | Condition as j => Condition(j)
       | Else as j => Else(j)
       | Target as j => Target(j, true)
       | Action as j => Action(j)
      }
    }
    
    public Traverse(func : DecisionNode -> void) : void
    {
      def traverse(t)
      {
        func(t);
        match (t)
        {
          | Condition(body = b, else_node = null) => traverse(b)
          | Condition(body = b, else_node = els) => traverse(b);traverse(els)
          | Action(body = b)
          | Else(body = b) => traverse(b)
          | Target => ()
        }
      }
            
      traverse(this)
    }
    
  }
  
  public variant TransitionBodyKind
  {
    | Normal
    | Junction {tree : DecisionNode;}
    | Choice {tree : DecisionNode;}
  }
}
