using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Compiler.Test
{
  /// <summary>
  /// Description of ExternalNcc.
  /// </summary>
  public sealed class ExternalNcc : Ncc
  {
    public this([NotNull] nccExecutable : NccExecutable)
    {
      _nccExecutable = nccExecutable;
    }

    public override Compile([NotNull] arguments : list[string], files : list[string]) : NccResult
    {
      def actualArguments = List();
      actualArguments.AddRange(_nccExecutable.Arguments);
      actualArguments.AddRange(arguments);
      actualArguments.AddRange(files);

      def startInfo = ProcessStartInfo();
      startInfo.FileName = _nccExecutable.FileName;
      startInfo.Arguments = string.Join(" ", actualArguments.Select(sanitizeArgument));
      startInfo.RedirectStandardOutput = true;
      startInfo.UseShellExecute = false;

      using(nccProcess = Process.Start(startInfo))
      {
        def compilerOutput = List();
        mutable line = nccProcess.StandardOutput.ReadLine();
        while(!ReferenceEquals(null, line))
        {
          compilerOutput.Add(line);
          line = nccProcess.StandardOutput.ReadLine();
        }

        unless (nccProcess.WaitForExit(20000) || nccProcess.HasExited)
          nccProcess.Kill();

        NccResult(nccProcess.ExitCode, compilerOutput.ToArray())
      }
    }

    private static sanitizeArgument(value : string) : string
    {
      if(value.IndexOf(' ') >= 0)
        "\"" + value + "\""
      else
        value
    }

    private _nccExecutable : NccExecutable;
  }
}
