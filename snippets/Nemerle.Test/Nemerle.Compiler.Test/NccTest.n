using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Test.Framework;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Nemerle.Compiler.Test
{
  /// <summary>
  /// Description of NccTest.
  /// </summary>
  public sealed class NccTest : Test
  {
    public this([NotNull] compiler : Ncc, filePath : string, [NotNull] globalReferencies : IEnumerable[string], [NotNull] globalOptions : IEnumerable[string])
      requires !string.IsNullOrEmpty(filePath)
    {
      _compiler = compiler;
      _filePath = Path.GetFullPath(filePath);
      def fileDirectory = Path.GetDirectoryName(_filePath);
      def fileName = Path.GetFileName(_filePath);
      _name = if(string.IsNullOrEmpty(fileDirectory)) fileName else Path.Combine(fileDirectory, fileName);
      _globalReferencies = globalReferencies.ToArray();
      _globalOptions = globalOptions.ToArray();
    }

    public override Run() : Result
    {
      mutable reader;
      try
      {
        reader = File.OpenText(_filePath)
      }
      catch
      {
        | _ is FileNotFoundException =>
          return Result.Fail($"File '$_filePath' does not exist")
        | _ is DirectoryNotFoundException =>
          return Result.Fail($"This path '$_filePath' is invalid")
        | _ is PathTooLongException =>
          return Result.Fail($"This path '$_filePath' is too long")
      }
      def description = try NccTestParser.Parse(reader) finally reader.Dispose();
      when(description.NoTest)
        return Result.UnableToRun("not a test");
      Result.Success()
    }

    private compilationStep(description : NccTestDescription) : string * bool
    {
      def compilationOptions = List();

      foreach(reference in _globalReferencies)
        compilationOptions.Add("-r:" + reference);

      foreach(reference in description.Referencies)
        compilationOptions.Add("-r:" + reference);

      compilationOptions.AddRange(description.Options);

      foreach(package in description.Packages)
        compilationOptions.Add("-pkg-config:" + package);

      compilationOptions.AddRange(_globalOptions);

      def objectFileName = 
        if(description.HasExpectedOutput)
        {
          compilationOptions.Add("-t:exe");
          Path.GetFileNameWithoutExtension(_filePath) + ".exe"
        }
        else
        {
          compilationOptions.Add("-t:library");
          Path.GetFileNameWithoutExtension(_filePath) + ".dll"
        };
      compilationOptions.Add("-out:" + objectFileName);
    }

    public override Name : string { get { _name } }

    private _compiler : Ncc;
    private _filePath : string;
    private _name : string;
    private _globalReferencies : array[string];
    private _globalOptions : array[string];
  }
}
