using Nemerle.Utility;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.NamespaceTree;
using Nemerle.Imperative;
using Nemerle.Compiler.Utils;

namespace Nemerle.Completion2
{
  [Record]
	public class NemerleCompletionResult
	{
	  public CompletionList : array[CompletionElem] { get; }
	  public Env            : GlobalEnv             { get; }
	  
	  [Record]
	  public class UsingInfo
	  {
	    public NeedUsing : bool { get; }
	    public Hiden     : bool { get; }
	    public Namespase : string { get; }
	    public Alias     : string { get; }
	  }

	  public static NamespaceNameToString(namespaceName : list[string]) : string { $<#..$(namespaceName; ".")#> }
	  
	  public static CalcUsingDeclarationInsertionLine(namespaceName : string, compileUnit : CompileUnit) : int
	  {
	    foreach (decl in compileUnit.TopNamespace.Decls)
	    {
	      | Using(Name=name, Alias=alias) as u =>
	        when (!alias.IsNullOrEmpty() || namespaceName.CompareTo(NamespaceNameToString(name)) <= 0)
	          return u.Location.Line;
	        
	      | _ => ()
	    }
	    
	    1
	  }
	  
    public static CalcUsingDeclarationInfo(env : GlobalEnv, elem : Elem) : UsingInfo
    { 
      match (elem)
      {
        | Node(name, Node where(Value=TypeInfoCache.Cached(typeInfo)) as node) =>
          def members = env.LookupSymbol([name], null, false);
          def ns1     = NamespaceNameToString(node.Parent.FullName);
          
          if (members.Contains(typeInfo))
            UsingInfo(false, members.Length > 1, ns1, "")
          else
          {
            foreach ((alias, ns2) when ns1 == ns2 in env.NamespaceAliases)
              return UsingInfo(false, false, ns1, alias);
            
            UsingInfo(true, !members.IsEmpty, ns1, "")
          }

        | _ => assert(false)
      }
    }
  }
}
